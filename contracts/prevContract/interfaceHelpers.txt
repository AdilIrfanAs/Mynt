// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.7;
contract HelperContract {
    uint256 internal startDate = 1654089000; 
    uint256 internal constant shareRateMax = (1 << shareRateUintSize) - 1;
    uint256 internal constant shareRateUintSize = 40;
    uint256 internal constant shareRateDecimals = 10 ** 5; 


    function findDay() external view returns(uint) {
        uint day = block.timestamp - startDate;
        day = day / 180;
        return day;
    }

    function findEndDayTimeStamp(uint256 day) external view returns(uint256){
       uint256 futureDays = day * 180;
       futureDays = block.timestamp + futureDays;
       return futureDays;
    }

    function findMin (uint256 value) public pure returns(uint256){
        uint256 maxValueBPB = 150000000 * 10 ** 8;
        uint256 minValue;
        if(value <=  maxValueBPB){
            minValue = value;
        }
        else{
            minValue = maxValueBPB; 
        }
       return minValue; 
    }

    function findBiggerPayBetter(uint256 inputPTP) public pure returns(uint256){
        uint256 divValueBPB = 1500000000 * 10 ** 8;
        uint256 minValue =  findMin(inputPTP);
        uint256 BPB = inputPTP * minValue;
        BPB = BPB / divValueBPB; 
        return BPB;
    } 

    function findLongerPaysBetter(uint256 inputPTP, uint256 numOfDays) public pure returns(uint256){
        if(numOfDays > 3641){
            numOfDays = 3641;
        }
        uint256 daysToUse = numOfDays - 1; 
        uint256 LPB = inputPTP * daysToUse;
        LPB = LPB / 1820;
        return LPB;
    } 

    function findBPDPercent (uint256 share,uint256 totalSharesOfBPD) external pure returns (uint256){
        uint256 totalShares = totalSharesOfBPD;
        uint256 sharePercent = share * 10 ** 4;
        sharePercent = sharePercent / totalShares;
        sharePercent = sharePercent * 10 ** 2;
        return sharePercent;   
    }

    function _calcAdoptionBonus(uint256 payout,uint256 claimedBtcAddrCount,uint256 claimedBTC,uint256 unClaimedBtc)external pure returns (uint256){
        uint256 claimableBtcAddrCount = 27997742;
        uint256 bonus = 0;
        uint256 viral = payout * claimedBtcAddrCount;
        viral = viral / claimableBtcAddrCount;
        uint256 crit = payout * claimedBTC;
        crit = crit / unClaimedBtc;
        bonus = viral + crit;
        return bonus; 
    }

    function findDayDiff(uint256 endDayTimeStamp) public view returns(uint) {
        uint day = block.timestamp - endDayTimeStamp;
        day = day / 180;
        return day;
    }

    function generateShare(uint256 inputPTP, uint256 LPB , uint256 BPB,uint256 shareRate) external pure returns(uint256){
            uint256 share = LPB + BPB;
            share = share + inputPTP;
            share = share / shareRate;
            share = share * shareRateDecimals;
            return share;  
    }

    function calcNewShareRate (uint256 fullAmount,uint256 stakeShares,uint256 stakeDays) external pure returns (uint256){
        uint256 BPB =  findBiggerPayBetter(fullAmount);
        uint256 LPB =  findLongerPaysBetter(fullAmount,stakeDays);
        uint256 newShareRate = fullAmount + BPB + LPB;
        newShareRate = newShareRate * shareRateDecimals;
        newShareRate = newShareRate / stakeShares;
        if (newShareRate > shareRateMax) {
                /*
                    Realistically this can't happen, but there are contrived theoretical
                    scenarios that can lead to extreme values of newShareRate, so it is
                    capped to prevent them anyway.
                */
                newShareRate = shareRateMax;
            }
        return newShareRate ;
    }

    function findSillyWhalePenalty(uint256 amount) external pure returns (uint256){
        if(amount < 1000e8){
            return amount;
        }
        else if(amount >= 1000e8 && amount < 10000e8){  
            uint256 penaltyPercent = amount - 1000e8;
            penaltyPercent = penaltyPercent * 25 * 10 ** 2;
            penaltyPercent = penaltyPercent / 9000e8; 
            penaltyPercent = penaltyPercent + 50 * 10 ** 2; 
            uint256 deductedAmount = amount * penaltyPercent; 
            deductedAmount = deductedAmount / 10 ** 4;          
            uint256 adjustedBtc = amount - deductedAmount;  
            return adjustedBtc;   
        }
        else { 
            uint256 adjustedBtc = amount * 25;
            adjustedBtc = adjustedBtc / 10 ** 2;
            return adjustedBtc;  
        }
    }

    function findLatePenaltiy(uint256 dayPassed) external pure returns (uint256){
        uint256 totalDays = 350;
        uint256 latePenalty = totalDays - dayPassed;
        latePenalty = latePenalty * 10 ** 4;
        latePenalty = latePenalty / 350;
        return latePenalty; 
    }

    function findSpeedBonus(uint256 day,uint256 share) external pure returns (uint256){
      uint256 speedBonus = 0;
      uint256 initialAmount = share;
      uint256 percentValue = initialAmount * 20;
      uint256 perDayValue = percentValue / 350;  
      uint256 deductedAmount = perDayValue * day;      
      speedBonus = percentValue - deductedAmount;
      return speedBonus;

    }

    function findReferalBonus(address user,uint256 share,address referer) external pure returns(uint256) { 
       uint256 fixedAmount = share;
       uint256 sumUpAmount = 0;
      if(referer != address(0)){
       if(referer != user){
         
        // if referer is not user it self
        uint256 referdBonus = fixedAmount * 10;
        referdBonus = referdBonus / 100;
        sumUpAmount = sumUpAmount + referdBonus;
       }
       else{
        // if a user referd it self  
        uint256 referdBonus = fixedAmount * 20;
        referdBonus = referdBonus / 100;
        sumUpAmount = sumUpAmount + referdBonus;
        }
       }
       return sumUpAmount;
    }

    function countShare (uint256 userSubmittedBNB, uint256 dayTotalBNB, uint256 availablePTP) external pure returns  (uint256) {
        uint256 share = 0;
        //to avoid decimal issues we add 10 ** 5
        share = userSubmittedBNB * 10 ** 5 / dayTotalBNB;
        share = share * availablePTP;
        return share / 10 ** 5;
    }

}